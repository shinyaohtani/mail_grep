# CODE_INTRODUCTION — MailGrep プロジェクトの徹底解説

このドキュメントは、リポジトリ内の主要コンポーネント（クラス／関数／定数）の「名称・役割・デザイン意図・使いどころ」を、実装の流れとともに立体的に紹介します。単なる API 紹介に留まらず、各コンポーネントがどんな“かっこよさ”を持つのか、どのように堅牢さと柔軟さを両立しているのかを丁寧に言語化します。

---

## 全体像（Overview）

本プロジェクトは macOS Mail の `.emlx` を対象に、`egrep` 互換の正規表現でメール本文やヘッダを検索し、ヒット結果を CSV / XLSX に整形出力するユーティリティです。エントリポイントは `mail_grep.py` の `main()` で、引数解析（`AppArguments`）→ メールソースの列挙（`MailFolder`）→ メッセージの構文解析（`MailMessage` とその内部コンポーネント）→ パターンマッチ（`SearchPattern`）→ ヒット行の正規化（`HitLine`）→ レポート集計と保存（`HitReport`）という直線的で読みやすいデータフローに整理されています。

“かっこよさ”の源泉は、**入力が雑多でも出力を均質化**する設計思想です。メールは多言語・多エンコード・多パートという混沌が常態ですが、本コードはヘッダ解読（`EncodedHeader`）、本文抽出（`_MailBody`）、 CSV セル安全化（`CsvFieldText`）などの境界面を小さな責務に分割し、例外や欠損に強い振る舞いを実現しています。さらに `SmartLogging` により、実行中の視認性とトラブルシュート耐性を高め、CLI ユーティリティとしての完成度を押し上げています。

出力は実務に寄り添っています。Excel での運用を前提とした BOM 付き UTF-8、`HYPERLINK()` によるメッセージリンク列、改行の可視化など、**“データが開いた瞬間に使える”**ことを徹底。レポートはデフォルトで最新メールが上位に来るよう日付降順で並び替え、かつ `hit_id==1` だけを初期表示する Excel フィルタを仕込み、調査効率に直結する体験を提供します。

最後に、部品間の結合は最小限です。正規表現変換（`SearchPattern._egrep_to_python_regex`）や本文バリアント生成（HTML→テキスト）など、“変換器”は外部から差し替え可能な関数・小クラスに集約。**“外科手術のようにピンポイントに改変できる”**構造が保守性を支えています。

---

## `hit_line.py` — `HitLine`

`HitLine` はレポートの最小単位、「１つのメールの中で、パターンにヒットした１行」を表す値オブジェクトです。`mail_id`（入力順のシーケンシャル ID）、`hit_count`（同一メール内でのヒット通番）、そして本文断片やどのパートにヒットしたかを保持します。コンストラクタでは与えられた文字列行を `strip()` して余計な前後空白を削除し、以後の比較・整形で不要なノイズが混ざらないよう最初に整えておきます。

このクラスの美点は、自ら表示ロジックを持たず **“列の順序”** だけを知っている点です。`values()` は出力順に並んだフィールド配列を返すだけに留め、最終的な見た目やファイル形式（CSV/XLSX）は上位の `HitReport` に委ねます。これにより `HitLine` は永続化フォーマットから独立し、**出力先の選択自由度**が確保されます。

各フィールドは `CsvFieldText.sanitize()` を通すことで、改行や CR を Excel でも壊れない形（`\r` を削除、`\n` を“⏎”）に正規化します。実務ではメール断片に制御文字が紛れ込むことが珍しくありませんが、ここで吸収してしまうため、**後工程がシンプル**になります。文字化けや多バイトを気にせず“並べる”という責務に集中できるのが、このクラスのかっこいいところです。

最後に、`HitLine` は `MailProfile` を抱えます。これは、メッセージ ID・日時・差出人・宛先・件名・Excel で開くためのリンク式など、検索より上流で抽出された“メールのキー情報”の束です。`HitLine` は **“検索文脈＋メール鍵”** を一体として移動させる運搬役であり、後段の並べ替え・フィルタ・書き出しが気持ちよく行えるよう、最低限にして充分な情報を携えています。

---

## `hit_report.py` — `HitReport`

`HitReport` は `HitLine` の収集・整列・保存を一手に引き受ける集計器です。内部には単純なリスト `hit_lines` を持ち、`append_hit_line()` で逐次追加、`sort()` で並べ替え、`store()` で CSV / XLSX にエクスポートします。**状態は極力小さく、操作は明確に**というポリシーで、レポート作成の制御点を３手に絞っています。

並べ替えキーのデザインが秀逸です。`date_dt`（`datetime | None`）を使い、`None` は末尾に回すタプルキー `(dt is None, -timestamp)` により、欠落した日時を自然に“後回し”しつつ、新しいメールほど上位に置く降順を実現します。これにより運用者は常に最新のヒットから確認でき、**調査の時間軸がぶれない**体験になります。

書き出しは実用第一です。CSV は BOM 付き UTF-8 で保存し、Excel を想定した互換性を確保。XLSX は `openpyxl` を用いて、オートフィルタの有効化・列幅の近似自動調整・既定フィルタ（`hit_id==1` のみ表示）まで仕込みます。リンク列は CSV と同じく `HYPERLINK()` で保持するため、**どちらの形式でも行間の情報量が損なわれません**。

ロギングも抜かりありません。保存パスのログは `[MailGrep]` プレフィックスで一貫し、失敗時も警告で落とすだけにとどめて処理継続を優先します。トラブルが起きても“結果は残す”という哲学が、`finally` セクションでの保存と併せて、**現場で頼れるツール**の風格を与えています。

---

## `mail_string_utils.py` — `CsvFieldText` / `AnyText` / `EncodedHeader`

`CsvFieldText` は「CSV の 1 セルに安全に入る文字列」を提供するユーティリティです。`sanitize()` が CR 削除と LF→“⏎” 変換を行い、Excel での表示崩れやセル内改行による可読性低下を防ぎます。メール断片は目に見えない制御文字を含みがちですが、ここで“無害化”されるため、以降の処理は **文字列としての一貫性**に自信を持てます。

`AnyText` は“何でも文字列にする”ための変換器です。`bytes` や email の `AddressHeader` ライクなオブジェクトを受け取り、UTF-8 デコードや `str()` 落としにより丸く収めます。例外を飲み込んで空文字を返す振る舞いは議論の余地がありますが、本プロジェクト文脈では **パイプラインの中断よりも進行を優先**する判断が合理的です。メールという“不均質な世界”に対して、実用的な寛容さを体現しています。

`EncodedHeader` は MIME エンコード断片（`=?UTF-8?B?...?=` 等）で構成されるヘッダ値を、確実に人間可読へ復元する専門職です。`decode()` では `decode_header()` の断片配列を走査し、宣言エンコード失敗時は UTF-8 → Latin-1 の順でフォールバック、最終的に `repr(bytes)` で“失敗を可視化”します。加えて `remove_crlf()` による CR 除去・LF→スペース統一で、**単一行の安全なヘッダ文字列**を作ります。ここまでやるから、上位は“表示に集中”できます。

この三位一体が、ヘッダと本文の**境界の難しさを吸収する緩衝材**になっています。CSV 向け整形、メール特有のオブジェクト→文字列化、MIME エンコーディング復号という異なる層を分離し、単機能を積み上げることで、全体としては“壊れにくい実務エンジン”を成立させています。

---

## `mail_profile.py` — `MailProfile`

`MailProfile` はメール 1 通を人間の仕事にとって意味のある鍵情報へ圧縮した **不変（frozen）データクラス**です。メッセージ ID / 日付（文字列と `datetime`）/ `message:` スキームのリンク / 件名 / From / To を束ね、検索結果の各ヒット行に“文脈”を与えます。不変であることは並列処理やキャッシュ戦略にも利点をもたらし、**読み取り中心のワークロードに噛み合う**性質です。

このクラスの小さな光は `excel_link` プロパティにあります。Excel 上で実際にクリックできる `HYPERLINK()` 式を返すため、表計算環境における“現場導線”が最短化されます。メールの原本参照は調査作業のコアであり、**結果テーブルからすぐ根源に戻れる**のはプロダクティビティに直結します。

`date_str` と `date_dt` の二重化は、表示と計算の分離という設計美を表しています。人間に優しい整形済み文字列と、機械に優しい `datetime` を併置することで、整列・集計・提示のすべてをシンプルにします。ここでも“上流で手当て、下流を軽く”という一貫した思想が顔を出します。

要するに `MailProfile` は、メール世界の複雑さを「レポートに必要な核心」に蒸留した **コンパクトな名刺**です。これ１枚で並べ替え基準も、参照リンクも、見出しも手に入り、周辺のクラスはそれを前提に思い切った最適化ができます。

---

## `mail_message.py` — `_MailBlob` / `_MailHeaders` / `_MailBody` / `MailMessage`

`_MailBlob` は `.emlx` ファイルの**生バイトを安全に取り出す**責務を持つ下働きです。Apple Mail 独自の先頭サイズ行を検出して取り除く処理を内包し、`BytesParser(policy=policy.default)` で `Message` へ変換します。失敗時に素朴な `email.message_from_bytes()` にフォールバックする戦略は、データの荒波に耐える“実務筋”が通っています。

`_MailHeaders` は `Message` からヘッダを解読し、人間可読化を徹底する層です。`id_str()`、`date_str()`、`date_dt()`、`link()`、`subj()`、`from_addr()`、`to_addr()` に加え、`lines()` では表示用の整形済み行配列を提供します。各取得は例外に強く、失敗しても空文字や `[INVALID HEADER]` で**可視化して前進**します。リンクは `message:<Message-ID>` 形式を厳格に整え、可搬な参照を担保しています。

`_MailBody` は“本文の抽出と標準化”の司令塔です。`_iter_text_parts()` で `text/*` を走査し、`_decode_payload()` が宣言 charset→UTF-8 の順にデコード。HTML の場合は生 HTML、改稿済みテキスト（head/script/style 除去・`get_text()`）、連結文字列（`stripped_strings` 連結）という **三つのバリアント**を生成します。これにより検索パターンは「タグ込み」「テキストのみ」「連結形」のいずれにも掛けられ、取りこぼしを最小化します。

`MailMessage` はこれらの内臓器官を束ねた**外側の器**です。コンストラクタで `_MailBlob` → `Message` → `_MailHeaders` / `_MailBody` → `MailProfile` を順に構築し、`extract(pattern)` がヘッダと本文（`text/plain` と `text/html_textonly`）を対象にマッチングを実行します。公開 API はきわめて少なく、`key_profile()` と `extract()` の二本柱。**取り出し口が少ない**からこそ、上位の `MailGrepApp` は迷いなく使えます。

---

## `search_pattern.py` — `SearchPattern`

`SearchPattern` は“egrep 表記を Python 正規表現に翻訳して使う”ための薄いラッパです。コンストラクタで `egrep_pattern` を受け取り、`_egrep_to_python_regex()` で POSIX 文字クラスの一部を Python 互換に写像、最後は `re.compile(..., flags | re.DOTALL)` で実戦投入。`check_line()` は `bool` を返すだけのインライン風味で、ホットパスに余計な抽象を挟まないのが心地よい設計です。

`unique_name` は出力ファイル名の自動生成器として気が利いています。NFKC 正規化→空白は `_` に→英数・アンダースコア以外の除去→`_` 連続の圧縮→先頭 16 文字→タイムスタンプ連結という工程で、**人が読みやすく衝突しにくい**ベース名を作ります。コマンドラインツールで“勝手にいい感じのファイル名が付く”体験は、想像以上に生産性を押し上げます。

`_egrep_to_python_regex()` のマッピングは段階的拡張が容易です。辞書差し替え・追加で対応範囲を増やせるため、プロジェクトの要件に応じて“必要なだけ”サポートを広げられます。実運用で大事なのはフル実装ではなく、**痛点の迅速なキャッチアップ**であり、そのための手触りの良い設計になっています。

総じて `SearchPattern` は、“入力の自由”と“実行時の確実さ”のちょうど真ん中に立つ案内役です。CLI から来る雑多な正規表現を、Python ランタイムが気持ちよく消化できる形に整える、この **翻訳家のようなクラス**が、検索体験の起点を支えます。

---

## `mail_folder.py` — `MailFolder`

`MailFolder` はファイルシステム境界を抽象化する極小クラスです。`root_dir` 以下を `rglob('*.emlx')` で再帰列挙し、パス配列を返すだけ。複雑さを一切持ち込まず、**供給者としての純度**を保ちます。I/O の責務をここに閉じ込めることが、上流の `MailGrepApp` を“テストしやすい純粋関数”に近づけます。

このクラスが“かっこいい”のは、必要が生じた時にいくらでも拡張できる点です。スパースチェック、サイズや更新日のフィルタ、排他リスト、あるいは `.mbox` など別形式への対応も、メソッドを足すだけで上位には波及しません。**境界面で将来の変更を隔離**する教科書的設計です。

`Path` を全面採用している点も堅実です。文字列ではなくオブジェクトでファイルパスを扱うことは、可搬性と安全性を底上げします。結果、呼び出し側では `Path` の合成・相対化・存在チェックなどのリッチな操作をそのまま活用でき、**バグの混入余地が減る**わけです。

総括すると、`MailFolder` は「やるべきことだけをやる」良い意味での無色透明さが魅力です。入出力の境界を静かに支えることで、全体の見通しをよくし、テスト・交換・差し替えを容易にする **基礎体力**を提供します。

---

## `smart_logging.py` — `SmartLogging` / `PROJ_ABSPATH` / `trancate()` / `_OnlyMyLogsFilter`

`SmartLogging` は“実行時の見通し”を最大化するためのロギング環境のファサードです。コンテキストマネージャ対応で、`with SmartLogging(level): ...` と書くだけで、コンソール出力・色付け（`colorlog`）・レベル制御・フィルタ・経過時間／ログファイルパスの後処理まで一括セットアップされます。**使う側は意図（どのレベルで見たいか）だけに集中**できます。

`initialize_logging()` は、ルートロガーを `DEBUG`、コンソールのストリームハンドラを `INFO` に固定してから、ユーザ指定レベルで最終調整する二段構えです。これにより「内部では詳細に記録するが、表に出す量は任意で調整」という、現場で嬉しい振る舞いが得られます。`_apply_colorlog_to_console_handler()` の色分けも、重大度が一目でわかる **視認性の良さ**に効いています。

`set_stream_filter(True)` で付与される `_OnlyMyLogsFilter` は、`PROJ_ABSPATH` 配下から発せられたログのみを通す **ノイズキャンセラ**です。ライブラリや外部モジュールが大量に出力する環境でも、自分のコードの声だけを拾い上げられます。失敗時にも False を返して落ちない設計は、フィルタが障害点にならないよう配慮された堅牢さの表れです。

補助関数 `trancate()`（※意図的にプロジェクト内表記を踏襲）は、長いテキストをエリプシスで切り詰める小粒なユーティリティです。ログは“読まれてナンボ”なので、冗長さを削って要点だけを素早く提示するのは立派な UX 改善です。`finalize_logging()` が出力する経過時間（`h:mm:ss`）とログファイル相対パスも、**実行履歴の心地よい締め**として効いています。

---

## `mail_grep.py` — `MailGrepApp` / `AppArguments` / `main()` / `line_preview()`

`AppArguments` は CLI フロントエンドです。検索パターン、`--ignore-case`、`--output`、`--source` を宣言的に定義し、健康的な `argparse` 実装に仕上がっています。デフォルトのメールソースを macOS の `~/Library/Mail/V10` に設定しているため、**最短１引数で始められる**のが嬉しいところです。パース失敗時は例外で明確に落とし、呼び出し側が責任を持って対処できます。

`MailGrepApp` はユースケースの中核です。ストレージ（`MailFolder`）から順次パスを受け取り、`MailMessage` が取り出した `MailProfile` と、`SearchPattern` マッチの結果行を `HitLine` に変換して `HitReport` へ蓄積します。CLI にはヒット時のプレビューを即時表示し、ユーザは実行中に“手応え”を得られます。`KeyboardInterrupt` を優雅に扱いつつ、`finally` で必ず保存する姿勢は **実務の味方**そのものです。

`line_preview()` は 50 文字での安全なサマリ生成です。標準出力はログと同様に **“視認性が命”** なので、端末幅や可読性に配慮した短縮表示は効率に直結します。プレビューはあくまで補助であり、完全な内容は CSV/XLSX に任せるという役割分担が明確です。

`main()` は配線役として徹底して薄く、初期化・実行・例外ログの三点に絞られています。トップレベルの `if __name__ == '__main__':` では `SmartLogging` を使い、`MAIL_GREP_DEBUG` でレベルを切り替えつつ、プロジェクト配下のみのログフィルタをオン。予期せぬ例外は詳細スタックをログと標準出力に両方残し、**現場での復旧速度を最優先**に設計されています。

---

## `setup.py` — セットアップエントリ

`setup.py` は極小のブートストラップです。`setuptools.setup()` 呼び出しのみを持ち、パッケージング設定は `setup.cfg` や `pyproject.toml` に寄せる現代流儀と親和的です。すなわち“ここでは何もしない”選択が、**他所に書くという明確な意思表示**になります。

この構成は、プロジェクトをライブラリ化・配布可能にする際の拡張ポイントでもあります。エントリポイントスクリプトを追加すれば、`pipx` での配布も視野に入り、運用環境へのインストール体験を近代化できます。小さく産んで大きく育てる、そのための **鉤爪（フック）** です。

---

## データフローまとめ

1. `MailFolder` が `.emlx` の一覧を供給する。
2. 各パスを `MailMessage` が安全に構文解析し、`MailProfile` と本文行群を提供する。
3. `SearchPattern` がヘッダ・本文に対してマッチ判定を行う。
4. ヒットごとに `HitLine` が行データを標準化する。
5. `HitReport` が並べ替え・保存（CSV/XLSX）を行い、`SmartLogging` が実行の見通しと余韻を整える。

この直線的パイプラインは、**交換しやすく、壊れにくく、読んで気持ちが良い**ように設計されています。各コンポーネントが自分のサイズを守ることで、全体の信頼性と開発速度が両立します。

---

## 拡張のヒント（Future Work）

- `SearchPattern` の POSIX クラス対応範囲の拡張、否定クラスやワード境界の簡易シンタックス追加。
- `MailFolder` にサイズ・更新日・差分走査（前回以降のみ）などのフィルタを追加し、超大規模ディレクトリに対応。
- `MailMessage._MailBody` におけるエンコード検出の強化、`chardet` や `charset-normalizer` といった検出器の条件付き適用。
- `HitReport` の XLSX スタイル最適化（ラップ・オートフィット・条件付き書式）や、メール単位でのシート分割オプション。
- `SmartLogging` のファイル出力ハンドラ追加とローテーション設定、JSON ログフォーマットの選択肢化。

これらはいずれも“境界に機能を足す”だけで中核のフローを崩さない拡張であり、現状設計の **拡張容易性** を裏付けます。

---

## 付録：命名とコーディングの小さな約束

- “変換器”は名詞＋動詞ではなく、**目的語を明確にした名詞**で置く（例：`CsvFieldText`、`EncodedHeader`）。
- 出力直前の整形は **一箇所に集約**（CSV/XLSX の整形は `HitReport`、セル整形は `CsvFieldText`）。
- 例外は **境界で握りつぶす**（メール世界の多様性を内部に持ち込まない）。
- ログは **現場の視認性**を優先（色分け、フィルタ、最後に“今日の成果”を出す）。

これらの小さな約束が積み重なって、**現場で使える、壊れにくい、読みやすい**コードベースが形作られています。

